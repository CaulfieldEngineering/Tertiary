name: Build and Upload

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:

  # Job: Build
  # ==========================================================================================
  # ==========================================================================================
  build:

    strategy:
      matrix:
        os: [macos-latest, windows-latest]
        build_type: [Release]
        version: [Full, Demo]
        include:
          - os: windows-latest
            cmake_arch: -A x64
          - os: macos-latest
            cmake_arch: -DCMAKE_OSX_ARCHITECTURES=x86_64

    runs-on: ${{ matrix.os }}

    # Checkout Code
    # ==========================================================================================
    steps:
    - name: Checkout code
      uses: actions/checkout@v4



    # Cache Dependencies
    # ==========================================================================================
    # - name: Cache dependencies
    #   id: cache-libs
    #   uses: actions/cache@v4
    #   with:
    #     path: | 
    #       ${{github.workspace}}/libs
    #     key: libs



    # Configure Projects
    # ==========================================================================================
    - name: Configure CMake
      run: |
        if [ "${{ matrix.version }}" == "Demo" ]; then
          cmake -S "${{github.workspace}}" -B "${{github.workspace}}/build" -DBUILD_DEMO=ON ${{ matrix.cmake_arch }} -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
        elif [ "${{ matrix.version }}" == "Full" ]; then
          cmake -S "${{github.workspace}}" -B "${{github.workspace}}/build" -DBUILD_DEMO=OFF ${{ matrix.cmake_arch }} -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
        else
          echo "Unexpected version: ${{ matrix.version }}"
          exit 1
        fi
      shell: bash



    # Compile Executables
    # ==========================================================================================
    - name: Build
      run: cmake --build ${{github.workspace}}/build --config ${{ matrix.build_type }}



    # Gather project variables from config.cmake
    # ==========================================================================================
    - name: Extract and Set Configuration Variables
      run: |
        echo "Reading configuration from config.cmake..."
        while IFS=' ' read -r key value
        do
          value=$(echo $value | tr -d '"')  # Remove quotes
          echo "$key=$value" >> $GITHUB_ENV
        done < <(grep 'set(w' ${GITHUB_WORKSPACE}/config.cmake | sed -e 's/set(//g' -e 's/)//g' -e 's/\s\+/ /g')
      shell: bash
      


      # Debug; print project variables
      # ==========================================================================================
    - name: Use Variables
      run: |
        echo "Plugin Name: $wPLUGIN_NAME"
        echo "Company Name: $wCOMPANY_NAME"
        echo "Project Version: $wPROJECT_VERSION"
        echo "Manufacturer Code: $wPLUGIN_MANUFACTURER_CODE"
        echo "Formats: $wFORMATS"
        echo "Is Synth: $wIS_SYNTH"
        echo "Needs MIDI Input: $wNEEDS_MIDI_INPUT"
        echo "Needs MIDI Output: $wNEEDS_MIDI_OUTPUT"
        echo "Plugin Code: $wPLUGIN_CODE"



    # Install Inno Setup (Windows Only)
    # ==========================================================================================
    - name: Install Inno Setup (Windows Only)
      if: matrix.os == 'windows-latest'
      run: choco install innosetup --yes



    # Sign Payload (Win)
    # ==========================================================================================



    # Sign Payload (Mac)
    # ==========================================================================================



    # Compile Inno Setup script (Windows Only)
    # ==========================================================================================
    - name: Compile Inno Setup script (Windows Only)
      if: matrix.os == 'windows-latest'
      run: |
        & 'C:\Program Files (x86)\Inno Setup 6\ISCC.exe' "${{github.workspace}}\build\installer_win.iss"
      shell: pwsh



    # Package: Standalone (Mac)
    # ==========================================================================================
    - name: Create Standalone Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        mkdir -p ${GITHUB_WORKSPACE}/build/output
    
        # Format COMPANY_NAME by removing spaces
        FORMATTED_COMPANY_NAME=$(echo "$wCOMPANY_NAME" | tr -d ' ')

        echo "Using formatted company name: $FORMATTED_COMPANY_NAME"
        echo "Using version: $VERSION"

        pkgbuild \
          --root "${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/Standalone" \
          --identifier com.${FORMATTED_COMPANY_NAME}.${REPOSITORY_NAME}.vst3 \
          --version $wPROJECT_VERSION \
          --install-location /Applications/${REPOSITORY_NAME} \
          ${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_Standalone.pkg

        

    # Package: VST3 (Mac)
    # ==========================================================================================
    - name: Create VST3 Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        mkdir -p ${GITHUB_WORKSPACE}/build/output

        # Format COMPANY_NAME by removing spaces
        FORMATTED_COMPANY_NAME=$(echo "$wCOMPANY_NAME" | tr -d ' ')

        echo "Using formatted company name: $FORMATTED_COMPANY_NAME"
        echo "Using version: $VERSION"

        pkgbuild \
          --root "${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/VST3" \
          --identifier com.${FORMATTED_COMPANY_NAME}.${REPOSITORY_NAME}.vst3 \
          --version $wPROJECT_VERSION \
          --install-location /Library/Audio/Plug-Ins/VST3 \
          ${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_VST3.pkg



    # Package: Distribution (Mac)
    # ==========================================================================================
    - name: Create Distribution Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        mkdir -p ${GITHUB_WORKSPACE}/build/output
        cp ${{github.workspace}}/build/distribution.xml ${GITHUB_WORKSPACE}/build/output/distribution.xml
        echo "File 'distribution.xml' copied to build/output folder."

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        productbuild \
          --distribution ${GITHUB_WORKSPACE}/build/output/distribution.xml \
          --package-path ${GITHUB_WORKSPACE}/build/output \
          ${{github.workspace}}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg
      shell: bash



    # Print build folder contents
    # ==========================================================================================
    - name: List Build Directory Contents
      run: |
        Write-Host "Listing all files and directories in the build/plugin directory:"
        Get-ChildItem -Path "${{github.workspace}}\build\" -Recurse
      shell: pwsh



    # Sign Installer (Win)
    # ==========================================================================================



    # Sign Installer (Mac)
    # ==========================================================================================


    # Notarize the Installer (Mac)
    # ==========================================================================================



    # Staple the Notarization Ticket (Mac)
    # ==========================================================================================

    

    # Setup SSH
    # ==========================================================================================
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.ID_GITHUB }}



    # Add Host Key (Windows)
    # ==========================================================================================
    - name: Add Host Key (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        if (-Not (Test-Path -Path $HOME/.ssh)) {
          New-Item -ItemType Directory -Path $HOME/.ssh
        }
        ssh-keyscan -p 7822 CaulfieldEngineering.com | Out-File -Append -Encoding ascii $HOME/.ssh/known_hosts



    # Add Host Key (macOS)
    # ==========================================================================================
    - name: Add Host Key (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -p 7822 CaulfieldEngineering.com >> ~/.ssh/known_hosts



    # Create SSH Configuration
    # ==========================================================================================
    - name: Create SSH Config
      shell: bash
      run: |
        mkdir -p ~/.ssh
        echo "Host CaulfieldEngineering.com
          HostName CaulfieldEngineering.com
          User caulfiel
          Port 7822
          MACs hmac-sha2-256
          StrictHostKeyChecking no" > ~/.ssh/config



    # Verify SSH Key and Connection
    # ==========================================================================================
    - name: Verify SSH Key and Connection
      shell: bash
      run: |
        echo "Checking loaded SSH keys:"
        ssh-add -l
        
        echo "Attempting SSH connection:"
        ssh -vvv CaulfieldEngineering.com exit



    # Debug SSH Connection
    # ==========================================================================================
    - name: Upload to Server (SCP)
      shell: bash
      run: |
        set -x  # Enable debugging output
    
        # Begin the upload process
        echo "Starting upload process"
    
        # Set the destination directory to the version number (e.g., v1.0.0)
        DEST_DIR="v${wPROJECT_VERSION}"
        echo "DEST_DIR set to: $DEST_DIR"
    
        # Extract the repository name from the GitHub repository environment variable
        REPO_NAME=$(echo $GITHUB_REPOSITORY | awk -F / '{print $2}')
        echo "REPO_NAME set to: $REPO_NAME"
    
        # Determine the source file based on the operating system
        if [ "${{ matrix.os }}" == "macos-latest" ]; then
          # macOS: Set the source file path for macOS installer
          SOURCE_FILE="${{github.workspace}}/build/${REPO_NAME}MacInstaller_${wPROJECT_VERSION}${{ matrix.version == 'Demo' && '.D' || '' }}.pkg"
          echo "macOS build: SOURCE_FILE set to $SOURCE_FILE"
        elif [ "${{ matrix.os }}" == "windows-latest" ]; then
          # Windows: Set the source file path for Windows installer
          SOURCE_FILE="${{github.workspace}}/build/${REPO_NAME}WinInstaller_${wPROJECT_VERSION}${{ matrix.version == 'Demo' && '.D' || '' }}.exe"
          echo "Windows build: SOURCE_FILE set to $SOURCE_FILE"
        else
          # Unsupported OS error
          echo "Unsupported OS: ${{ matrix.os }}"
          exit 1
        fi
    
        # Define the destination path on the remote server where files will be uploaded
        DEST_PATH="/home/caulfiel/public_html/plug-ins/${REPO_NAME}/uploads/${DEST_DIR}/"
        SERVER="CaulfieldEngineering.com"
        SSH_COMMAND="ssh $SERVER"
    
        # Check if the version-specific directory exists on the server
        echo "Checking if destination version directory exists on the server"
        if eval "$SSH_COMMAND 'test -d $DEST_PATH'"; then
          echo "Version directory exists: $DEST_PATH"
        else
          # Create the version-specific directory if it does not exist
          echo "Version directory does not exist, creating directory: $DEST_PATH"
          if eval "$SSH_COMMAND 'mkdir -p $DEST_PATH'"; then
            echo "Version directory created successfully"
          else
            echo "Failed to create version directory: $DEST_PATH"
            exit 1
          fi
        fi
    
        # Check if the source file exists before attempting the upload
        if [ -f "$SOURCE_FILE" ]; then
          echo "Source file exists"
        else
          echo "Source file does not exist"
          # List the files in the build directory to help debug
          ls -l ${{github.workspace}}/build/
          exit 1
        fi
    
        # Begin the SCP transfer to upload the file to the server
        SCP_COMMAND="scp -v \"$SOURCE_FILE\" \"$SERVER:$DEST_PATH\""
        echo "Executing SCP command: $SCP_COMMAND"
    
        if eval $SCP_COMMAND; then
          echo "SCP command succeeded"
        else
          echo "SCP command failed with exit code $?"
          exit 1
        fi
    
        # Disable debugging output
        set +x  



    # Upload Installers to WordPress Media Library
    # ==========================================================================================
    - name: Upload Installers to WordPress
      env:
        WORDPRESS_USERNAME: ${{ secrets.WORDPRESS_USERNAME }}
        WORDPRESS_APPLICATION_PASSWORD: ${{ secrets.WORDPRESS_APPLICATION_PASSWORD }}
        WORDPRESS_SITE: ${{ secrets.WORDPRESS_SITE }}
      shell: bash
      run: |
        set -e  # Exit immediately if any command exits with a non-zero status

        # Function to URL encode a string
        urlencode() {
          local string="${1}"
          local strlen=${#string}
          local encoded=""
          local pos c o
          for (( pos=0 ; pos<strlen ; pos++ )); do
            c=${string:$pos:1}
            case "$c" in
              [-_.~a-zA-Z0-9]) o="${c}" ;;
              *) printf -v o '%%%02x' "'$c"
            esac
            encoded+="${o}"
          done
          echo "${encoded}"
        }

        # Check if WordPress credentials are set
        if [ -z "$WORDPRESS_USERNAME" ] || [ -z "$WORDPRESS_APPLICATION_PASSWORD" ] || [ -z "$WORDPRESS_SITE" ]; then
          echo "WordPress credentials not set. Skipping WordPress upload step."
          exit 0
        fi

        # Extract repository name and set version-specific variables
        REPO_NAME=$(echo $GITHUB_REPOSITORY | awk -F / '{print $2}')
        
        # Correctly evaluate matrix.version
        if [ "${{ matrix.version }}" == "Demo" ]; then
          IS_DEMO=true
          SUFFIX=".D"
        else
          IS_DEMO=false
          SUFFIX=""
        fi

        # Set file paths and titles based on OS and version
        if [ "${{ matrix.os }}" == "macos-latest" ]; then
          FILE_PATH="${GITHUB_WORKSPACE}/build/${REPO_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"
          if [ "$IS_DEMO" == true ]; then
            FILE_TITLE="Tertiary Demo Installer v${wPROJECT_VERSION}${SUFFIX} for Mac"
          else
            FILE_TITLE="Tertiary Installer v${wPROJECT_VERSION}${SUFFIX} for Mac"
          fi
          FILE_NAME="${REPO_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"
        elif [ "${{ matrix.os }}" == "windows-latest" ]; then
          FILE_PATH="${GITHUB_WORKSPACE}/build/${REPO_NAME}WinInstaller_${wPROJECT_VERSION}${SUFFIX}.exe"
          if [ "$IS_DEMO" == true ]; then
            FILE_TITLE="Tertiary Demo Installer v${wPROJECT_VERSION}${SUFFIX} for Windows"
          else
            FILE_TITLE="Tertiary Installer v${wPROJECT_VERSION}${SUFFIX} for Windows"
          fi
          FILE_NAME="${REPO_NAME}WinInstaller_${wPROJECT_VERSION}${SUFFIX}.exe"
        else
          echo "Unsupported OS for WordPress upload"
          exit 1
        fi

        # Check if file exists
        if [ ! -f "$FILE_PATH" ]; then
          echo "File not found: $FILE_PATH"
          exit 1
        fi

        # Upload process differs for Demo and Full versions
        if [ "$IS_DEMO" == true ]; then
          echo "Uploading Demo Version to WordPress Media Library"
          
          # Search for existing file
          ENCODED_TITLE=$(urlencode "$FILE_TITLE")
          echo "Searching for existing file with title: $FILE_TITLE"
          EXISTING_FILE_RESPONSE=$(curl -s -X GET "${WORDPRESS_SITE}/wp-json/wp/v2/media?search=${ENCODED_TITLE}" \
            -u "$WORDPRESS_USERNAME:$WORDPRESS_APPLICATION_PASSWORD")
          EXISTING_FILE_ID=$(echo "$EXISTING_FILE_RESPONSE" | jq -r '.[] | select(.title.rendered == "'"$FILE_TITLE"'") | .id')

          # Delete existing file if found
          if [ -n "$EXISTING_FILE_ID" ]; then
            echo "Existing file found with ID: $EXISTING_FILE_ID. Deleting..."
            DELETE_RESPONSE=$(curl -s -X DELETE "${WORDPRESS_SITE}/wp-json/wp/v2/media/${EXISTING_FILE_ID}?force=true" \
              -u "$WORDPRESS_USERNAME:$WORDPRESS_APPLICATION_PASSWORD")
            
            if echo "$DELETE_RESPONSE" | jq -e '.deleted == true' > /dev/null; then
              echo "Existing file successfully deleted."
            else
              echo "Failed to delete existing file. Response: $DELETE_RESPONSE"
              exit 1
            fi
          else
            echo "No existing file found with the exact title."
          fi

          # Upload new file
          echo "Uploading new file to WordPress..."
          UPLOAD_RESPONSE=$(curl -s -X POST "${WORDPRESS_SITE}/wp-json/wp/v2/media" \
            -u "$WORDPRESS_USERNAME:$WORDPRESS_APPLICATION_PASSWORD" \
            -H "Content-Disposition: attachment; filename=$(basename "$FILE_PATH")" \
            -F "file=@${FILE_PATH}" \
            -F "title=${FILE_TITLE}" \
            -F "alt_text=${REPO_NAME} Installer" \
            -F "caption=Installer for ${REPO_NAME} v${wPROJECT_VERSION}${SUFFIX}" \
            -F "description=${FILE_TITLE}")

        else
          echo "Uploading Full Version to WooCommerce Folder"
          
          # Attempt to delete existing file
          echo "Attempting to delete existing file before upload..."
          DELETE_RESPONSE=$(curl -s -X DELETE "${WORDPRESS_SITE}/wp-json/custom/v1/upload-file-to-woo" \
            -u "$WORDPRESS_USERNAME:$WORDPRESS_APPLICATION_PASSWORD" \
            -H "Content-Type: application/json" \
            -d "{\"filename\":\"$FILE_NAME\"}")

          if echo "$DELETE_RESPONSE" | grep -q "File deleted successfully"; then
            echo "Existing file deleted successfully."
          elif echo "$DELETE_RESPONSE" | grep -q "File not found"; then
            echo "No existing file found. Proceeding with upload."
          else
            echo "Unexpected response during delete attempt: $DELETE_RESPONSE"
          fi

          # Upload new file
          echo "Uploading full version file to WordPress using custom endpoint..."
          UPLOAD_RESPONSE=$(curl -s -X POST "${WORDPRESS_SITE}/wp-json/custom/v1/upload-file-to-woo" \
            -u "$WORDPRESS_USERNAME:$WORDPRESS_APPLICATION_PASSWORD" \
            -F "file=@${FILE_PATH}")
        fi

        # Check upload response and extract URL
        if [ "$IS_DEMO" == true ]; then
          if echo "$UPLOAD_RESPONSE" | jq -e '.id' > /dev/null; then
            echo "PASS: Demo version file successfully uploaded."
            FILE_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.source_url')
          else
            echo "FAIL: Upload failed. Response: $UPLOAD_RESPONSE"
            exit 1
          fi
        else
          if echo "$UPLOAD_RESPONSE" | grep -q "File uploaded successfully"; then
            echo "PASS: Full version file successfully uploaded."
            FILE_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.url')
          else
            echo "FAIL: Upload failed. Response: $UPLOAD_RESPONSE"
            exit 1
          fi
        fi

        echo "Uploaded file URL: $FILE_URL"

        # Extract and save URL root path
        URL_ROOT_PATH=$(dirname "$FILE_URL")
        echo "URL root path: $URL_ROOT_PATH"
        echo "URL_ROOT_PATH=$URL_ROOT_PATH" >> $GITHUB_ENV


    # Update WooCommerce Fields
    # ==========================================================================================
    - name: Update WooCommerce Downloadable Files
      if: matrix.version == 'Full'
      env:
        WOOCOMMERCE_CONSUMER_KEY: ${{ secrets.WOO_CK }}
        WOOCOMMERCE_CONSUMER_SECRET: ${{ secrets.WOO_CS }}
        WORDPRESS_SITE_URL: ${{ secrets.WORDPRESS_SITE }}
        WORDPRESS_PRODUCT_ID: ${{ secrets.WORDPRESS_PRODUCT_ID }}
      shell: bash
      run: |
        set -e
        
        echo "Starting WooCommerce update step..."
        
        # Debug: Print all environment variables used
        echo "WOOCOMMERCE_CONSUMER_KEY: ${WOOCOMMERCE_CONSUMER_KEY:0:4}**** (masked for security)"
        echo "WOOCOMMERCE_CONSUMER_SECRET: ${WOOCOMMERCE_CONSUMER_SECRET:0:4}**** (masked for security)"
        echo "WORDPRESS SITE URL: $WORDPRESS_SITE_URL"
        echo "WORDPRESS_PRODUCT_ID: $WORDPRESS_PRODUCT_ID"
        
        # Check if all required environment variables are set
        if [ -z "$WOOCOMMERCE_CONSUMER_KEY" ] || [ -z "$WOOCOMMERCE_CONSUMER_SECRET" ] || [ -z "$WORDPRESS_SITE_URL" ] || [ -z "$WORDPRESS_PRODUCT_ID" ]; then
          echo "Error: Required WooCommerce credentials or Product ID not set. Skipping WooCommerce update step."
          exit 0
        fi
    
        # Fetch existing product details to get current download IDs
        API_ENDPOINT="${WORDPRESS_SITE_URL}/wp-json/wc/v3/products/${WORDPRESS_PRODUCT_ID}"
        AUTH="${WOOCOMMERCE_CONSUMER_KEY}:${WOOCOMMERCE_CONSUMER_SECRET}"
        EXISTING_PRODUCT=$(curl -s -X GET "${API_ENDPOINT}" -u "$AUTH" -H "Content-Type: application/json")
        
        # Extract existing download details for both macOS and Windows files
        DOWNLOAD_ID_WIN=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)win")) | .id')
        FILE_NAME_WIN=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)win")) | .name')
        FILE_URL_WIN=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)win")) | .file')
        
        DOWNLOAD_ID_MAC=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)mac")) | .id')
        FILE_NAME_MAC=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)mac")) | .name')
        FILE_URL_MAC=$(echo "$EXISTING_PRODUCT" | jq -r '.downloads[] | select(.name | test("(?i)mac")) | .file')
        
        # Extract the repository name from the GitHub repository environment variable
        REPO_NAME=$(echo $GITHUB_REPOSITORY | awk -F / '{print $2}')
        echo "REPO_NAME set to: $REPO_NAME"

        # Update the file URLs and names dynamically based on the root path
        FILE_URL_WIN="${URL_ROOT_PATH}/${REPO_NAME}WinInstaller_${wPROJECT_VERSION}.exe"
        FILE_NAME_WIN="${REPO_NAME} v${wPROJECT_VERSION} for Windows"

        FILE_URL_MAC="${URL_ROOT_PATH}/${REPO_NAME}MacInstaller_${wPROJECT_VERSION}.pkg"
        FILE_NAME_MAC="${REPO_NAME} v${wPROJECT_VERSION} for Mac"

        # Output the dynamic URLs and names for debugging
        echo "Windows file URL: $FILE_URL_WIN"
        echo "Windows file name: $FILE_NAME_WIN"
        echo "Mac file URL: $FILE_URL_MAC"
        echo "Mac file name: $FILE_NAME_MAC"
        
        echo "Using file: $FILE_NAME_WIN with URL: $FILE_URL_WIN"
        echo "Using file: $FILE_NAME_MAC with URL: $FILE_URL_MAC"
        
        # Prepare JSON payload to update both downloadable files
        PAYLOAD=$(jq -n --arg name_win "$FILE_NAME_WIN" --arg url_win "$FILE_URL_WIN" --arg id_win "$DOWNLOAD_ID_WIN" \
                              --arg name_mac "$FILE_NAME_MAC" --arg url_mac "$FILE_URL_MAC" --arg id_mac "$DOWNLOAD_ID_MAC" \
                              '{
                                "downloads": [
                                    {
                                        "id": $id_win,
                                        "name": $name_win,
                                        "file": $url_win
                                    },
                                    {
                                        "id": $id_mac,
                                        "name": $name_mac,
                                        "file": $url_mac
                                    }
                                ]
                              }')
        
        echo "JSON Payload: $PAYLOAD"
        
        # Make API request to update the product's downloadable files
        RESPONSE=$(curl -s -X PUT "${API_ENDPOINT}" \
          -u "$AUTH" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD")
        
        echo "API Response: $RESPONSE"
        
        # Check if the update was successful
        if echo "$RESPONSE" | jq -e '.id' > /dev/null; then
          echo "Product downloads updated successfully."
        else
          echo "Error: Failed to update product downloads. Response: $RESPONSE"
          exit 1
        fi