# macos_pkg.yml
name: 'Package macOS'
description: 'Create and sign macOS packages'

inputs:
  version:
    required: true
    type: string
  mac_application_certificate:
    required: true
    type: string
  mac_certificate_password:
    required: true
    type: string
  keychain_password:
    required: true
    type: string
  repository_name:
    required: true
    type: string

runs:
  using: composite
  steps:

    # Sign Payload (Mac) - 2024.10.25.
    # ==========================================================================================
    - name: Sign Mac Binaries
      if: matrix.os == 'macos-latest'
      env:
        APPLICATION_CERTIFICATE_BASE64: ${{ inputs.mac_application_certificate }}
        CERTIFICATE_PASSWORD: ${{ inputs.mac_certificate_password }}
        KEYCHAIN_PASSWORD: ${{ inputs.keychain_password }}
        REPOSITORY_NAME: ${{ inputs.repository_name }}
        
      run: |
        # Check for required secrets
        if [ -z "$APPLICATION_CERTIFICATE_BASE64" ] || [ -z "$CERTIFICATE_PASSWORD" ] || [ -z "$KEYCHAIN_PASSWORD" ]; then
          echo "Required secrets for application signing are not set. Skipping application signing step."
          exit 0
        fi

        echo "Starting the signing process for macOS binaries..."

        # Create temporary keychain
        # ====================================
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Import certificate to keychain
        # ====================================
        echo -n "$APPLICATION_CERTIFICATE_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
        security import "$RUNNER_TEMP/cert.p12" -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        security list-keychains -d user -s "$KEYCHAIN_PATH"
        security default-keychain -s "$KEYCHAIN_PATH"
        
        # Add certificate to partition list
        # ====================================
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        echo "Signing VST3 bundle..."
        # ====================================
        VST3_PATH="${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/VST3/${REPOSITORY_NAME}.vst3"
        codesign --force \
          --sign "Developer ID Application" \
          --verbose \
          --deep --strict --options=runtime --timestamp \
          "$VST3_PATH"

        echo "Verifying VST3 signature..."
        # ====================================
        codesign --verify --deep --verbose=2 "$VST3_PATH"
        # Only verify code signature, skip notarization check
        codesign --display --verbose=2 "$VST3_PATH"

        echo "Signing standalone application..."
        # ====================================
        APP_PATH="${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/Standalone/${REPOSITORY_NAME}.app"
        codesign --force \
          --sign "Developer ID Application" \
          --verbose \
          --deep --strict --options=runtime --timestamp \
          "$APP_PATH"

        echo "Verifying standalone application signature..."
        # ====================================
        codesign --verify --deep --verbose=2 "$APP_PATH"
        # Only verify code signature, skip notarization check
        codesign --display --verbose=2 "$APP_PATH"

        # Clean up
        # ====================================
        security default-keychain -s login.keychain
        security delete-keychain "$KEYCHAIN_PATH"
        rm "$RUNNER_TEMP/cert.p12"

        echo "Signing process completed successfully."

    # Package: Standalone (Mac)
    # ==========================================================================================
    - name: Create Standalone Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        # Create output directory
        mkdir -p ${GITHUB_WORKSPACE}/build/output

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        # Define paths
        APP_PATH="${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/Standalone/${REPOSITORY_NAME}.app"
        PKG_PATH="${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_Standalone_${wPROJECT_VERSION}${SUFFIX}.pkg"

        echo "Checking for standalone app before packaging..."
        if [ ! -d "$APP_PATH" ]; then
          echo "ERROR: Standalone app not found at: $APP_PATH"
          echo "Contents of $(dirname "$APP_PATH"):"
          ls -la "$(dirname "$APP_PATH")"
          exit 1
        fi

        echo "✓ Found standalone app at: $APP_PATH"
        echo "Creating standalone package..."

        pkgbuild \
          --root "$(dirname "$APP_PATH")" \
          --identifier "com.${wCOMPANY_ID}.${REPOSITORY_NAME}.app" \
          --version "$wPROJECT_VERSION" \
          --install-location "/Applications/${REPOSITORY_NAME}" \
          "$PKG_PATH"

        # Verify package was created and is not empty
        if [ ! -f "$PKG_PATH" ]; then
          echo "ERROR: Package was not created at: $PKG_PATH"
          exit 1
        fi

        if [ ! -s "$PKG_PATH" ]; then
          echo "ERROR: Created package is empty: $PKG_PATH"
          exit 1
        fi

        echo "✓ Successfully created standalone package at: $PKG_PATH"

        # Inspect the package metadata
        echo "Inspecting package metadata..."
        pkgutil --expand "$PKG_PATH" "${PKG_PATH%.pkg}_expanded"
        
        # Extract PackageInfo file to read the details
        PACKAGE_INFO="${PKG_PATH%.pkg}_expanded/PackageInfo"
        if [ -f "$PACKAGE_INFO" ]; then
          echo "PackageInfo contents:"
          cat "$PACKAGE_INFO" | grep -E 'identifier=|version=|install-location=|CFBundleIdentifier|CFBundleVersion|CFBundleName'
        else
          echo "ERROR: PackageInfo not found in the expanded package"
          exit 1
        fi

    # Package: VST3 (Mac)
    # ==========================================================================================
    - name: Create VST3 Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        # Create output directory
        mkdir -p ${GITHUB_WORKSPACE}/build/output

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        # Define paths
        VST3_PATH="${GITHUB_WORKSPACE}/build/plugin/${REPOSITORY_NAME}_artefacts/Release/VST3/${REPOSITORY_NAME}.vst3"
        PKG_PATH="${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_VST3_${wPROJECT_VERSION}${SUFFIX}.pkg"

        echo "Checking for VST3 bundle before packaging..."
        if [ ! -d "$VST3_PATH" ]; then
          echo "ERROR: VST3 bundle not found at: $VST3_PATH"
          echo "Contents of $(dirname "$VST3_PATH"):"
          ls -la "$(dirname "$VST3_PATH")"
          exit 1
        fi

        echo "✓ Found VST3 bundle at: $VST3_PATH"
        echo "Creating VST3 package..."

        pkgbuild \
          --root "$(dirname "$VST3_PATH")" \
          --identifier "com.${wCOMPANY_ID}.${REPOSITORY_NAME}.vst3" \
          --version "$wPROJECT_VERSION" \
          --install-location "/Library/Audio/Plug-Ins/VST3" \
          "$PKG_PATH"

        # Verify package was created and is not empty
        if [ ! -f "$PKG_PATH" ]; then
          echo "ERROR: Package was not created at: $PKG_PATH"
          exit 1
        fi

        if [ ! -s "$PKG_PATH" ]; then
          echo "ERROR: Created package is empty: $PKG_PATH"
          exit 1
        fi

        echo "✓ Successfully created VST3 package at: $PKG_PATH"

        # Inspect the package metadata
        echo "Inspecting package metadata..."
        pkgutil --expand "$PKG_PATH" "${PKG_PATH%.pkg}_expanded"
        
        # Extract PackageInfo file to read the details
        PACKAGE_INFO="${PKG_PATH%.pkg}_expanded/PackageInfo"
        if [ -f "$PACKAGE_INFO" ]; then
          echo "PackageInfo contents:"
          cat "$PACKAGE_INFO" | grep -E 'identifier=|version=|install-location=|CFBundleIdentifier|CFBundleVersion|CFBundleName'
        else
          echo "ERROR: PackageInfo not found in the expanded package"
          exit 1
        fi

    # Sign Individual Packages (Mac) - 2024.10.25 CLAUDE
    # ==========================================================================================
    - name: Sign Individual Packages
      if: matrix.os == 'macos-latest'
      env:
        INSTALLER_CERTIFICATE_BASE64: ${{ secrets.MAC_INSTALLER_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.MAC_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        # Check for required secrets
        if [ -z "$INSTALLER_CERTIFICATE_BASE64" ] || [ -z "$CERTIFICATE_PASSWORD" ] || [ -z "$KEYCHAIN_PASSWORD" ]; then
          echo "Required secrets for installer signing are not set. Skipping installer signing step."
          exit 0
        fi

        echo "Starting the package signing process..."

        # Create temporary keychain
        # ====================================
        KEYCHAIN_PATH=$RUNNER_TEMP/pkg-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Import certificate to keychain
        # ====================================
        echo -n "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
        security import "$RUNNER_TEMP/cert.p12" -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        security list-keychains -d user -s "$KEYCHAIN_PATH"
        security default-keychain -s "$KEYCHAIN_PATH"
        
        # Add certificate to partition list
        # ====================================
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        echo "Signing standalone package..."
        # ====================================
        STANDALONE_PKG="${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_Standalone_${wPROJECT_VERSION}${SUFFIX}.pkg"
        productsign --sign "Developer ID Installer" \
          "$STANDALONE_PKG" \
          "${STANDALONE_PKG%.pkg}_signed.pkg"

        echo "Verifying standalone package signature..."
        # ====================================
        pkgutil --check-signature "${STANDALONE_PKG%.pkg}_signed.pkg"

        echo "Signing VST3 package..."
        # ====================================
        VST3_PKG="${GITHUB_WORKSPACE}/build/output/${REPOSITORY_NAME}_VST3_${wPROJECT_VERSION}${SUFFIX}.pkg"
        productsign --sign "Developer ID Installer" \
          "$VST3_PKG" \
          "${VST3_PKG%.pkg}_signed.pkg"

        echo "Verifying VST3 package signature..."
        # ====================================
        pkgutil --check-signature "${VST3_PKG%.pkg}_signed.pkg"

        # Replace unsigned with signed packages
        # ====================================
        mv "${STANDALONE_PKG%.pkg}_signed.pkg" "$STANDALONE_PKG"
        mv "${VST3_PKG%.pkg}_signed.pkg" "$VST3_PKG"

        # Clean up
        # ====================================
        security default-keychain -s login.keychain
        security delete-keychain "$KEYCHAIN_PATH"
        rm "$RUNNER_TEMP/cert.p12"

        echo "Package signing process completed successfully."

    # Package: Distribution (Mac)
    # ==========================================================================================
    - name: Create Distribution Package (Mac Only)
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        mkdir -p ${GITHUB_WORKSPACE}/build/output

        # Determine the suffix and distribution file based on the version
        SUFFIX=""
        DIST_FILE="distribution-full.xml"
        
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
          DIST_FILE="distribution-demo.xml"
        fi

        # Copy the appropriate distribution file
        echo "Using distribution file: $DIST_FILE"
        if [ ! -f "${{github.workspace}}/build/$DIST_FILE" ]; then
          echo "ERROR: Distribution file not found: $DIST_FILE"
          echo "Contents of build directory:"
          ls -la ${{github.workspace}}/build/
          exit 1
        fi

        # Copy and verify
        cp "${{github.workspace}}/build/$DIST_FILE" "${GITHUB_WORKSPACE}/build/output/distribution.xml"
        if [ ! -f "${GITHUB_WORKSPACE}/build/output/distribution.xml" ]; then
          echo "ERROR: Failed to copy distribution file"
          exit 1
        fi
        echo "✓ Distribution file copied successfully"

        # Verify package path contains our packages
        echo "Checking for component packages..."
        ls -la ${GITHUB_WORKSPACE}/build/output/*.pkg
        
        echo "Creating distribution package..."
        productbuild \
          --distribution "${GITHUB_WORKSPACE}/build/output/distribution.xml" \
          --package-path "${GITHUB_WORKSPACE}/build/output" \
          "${{github.workspace}}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"

        # Verify the final package was created
        if [ ! -f "${{github.workspace}}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg" ]; then
          echo "ERROR: Failed to create distribution package"
          exit 1
        fi
        
        echo "✓ Distribution package created successfully"
        
      shell: bash

    # Sign Distribution Package (Mac)
    # ==========================================================================================
    - name: Sign Distribution Package
      if: matrix.os == 'macos-latest'
      env:
        INSTALLER_CERTIFICATE_BASE64: ${{ secrets.MAC_INSTALLER_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.MAC_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        # Check for required secrets
        if [ -z "$INSTALLER_CERTIFICATE_BASE64" ] || [ -z "$CERTIFICATE_PASSWORD" ] || [ -z "$KEYCHAIN_PASSWORD" ]; then
          echo "Required secrets for installer signing are not set. Skipping installer signing step."
          exit 0
        fi

        echo "Starting the distribution package signing process..."

        # Create temporary keychain
        # ====================================
        KEYCHAIN_PATH=$RUNNER_TEMP/dist-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Import certificate to keychain
        # ====================================
        echo -n "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
        security import "$RUNNER_TEMP/cert.p12" -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        security list-keychains -d user -s "$KEYCHAIN_PATH"
        security default-keychain -s "$KEYCHAIN_PATH"
        
        # Add certificate to partition list
        # ====================================
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        # Sign the distribution package
        UNSIGNED_PKG="${GITHUB_WORKSPACE}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"
        SIGNED_PKG="${GITHUB_WORKSPACE}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}_signed.pkg"

        echo "Signing distribution package..."
        productsign --sign "Developer ID Installer" \
          "$UNSIGNED_PKG" \
          "$SIGNED_PKG"

        # Verify the signature
        echo "Verifying package signature..."
        pkgutil --check-signature "$SIGNED_PKG"

        # Replace unsigned with signed package
        mv "$SIGNED_PKG" "$UNSIGNED_PKG"

        # Clean up
        security default-keychain -s login.keychain
        security delete-keychain "$KEYCHAIN_PATH"
        rm "$RUNNER_TEMP/cert.p12"

        echo "Distribution package signing completed successfully."

    # Notarize the Distribution Package (Mac) - 2024.10.25 CLAUDE
    # ==========================================================================================
    - name: Notarize Mac Distribution Package
      if: matrix.os == 'macos-latest'
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        REPOSITORY_NAME: ${{ github.event.repository.name }}
      run: |
        # Check for required secrets
        if [ -z "$APPLE_ID" ] || [ -z "$APPLE_TEAM_ID" ] || [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ]; then
          echo "Required secrets for notarization are not set. Skipping notarization step."
          exit 0
        fi

        echo "Starting the notarization process..."

        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi

        # Store the installer path
        INSTALLER_PATH="${GITHUB_WORKSPACE}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"

        # Create temporary keychain for notarization
        xcrun notarytool store-credentials "notarytool-profile" \
          --apple-id "$APPLE_ID" \
          --team-id "$APPLE_TEAM_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD"

        # Submit for notarization and capture the submission ID
        echo "Submitting for notarization..."
        SUBMISSION_RESPONSE=$(xcrun notarytool submit "$INSTALLER_PATH" --keychain-profile "notarytool-profile")
        SUBMISSION_ID=$(echo "$SUBMISSION_RESPONSE" | grep "id:" | head -n 1 | awk '{print $2}')

        if [ -z "$SUBMISSION_ID" ]; then
          echo "Failed to get submission ID"
          echo "Full submission response: $SUBMISSION_RESPONSE"
          exit 1
        fi

        echo "Captured Submission ID: $SUBMISSION_ID"

        # Add a timeout counter
        ATTEMPTS=0
        MAX_ATTEMPTS=30  # 15 minutes maximum (30 * 30 seconds)

        # Wait and check status
        while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
          echo "Checking status for submission ID: $SUBMISSION_ID"
          STATUS_RESPONSE=$(xcrun notarytool info "$SUBMISSION_ID" --keychain-profile "notarytool-profile")
          echo "Full status response: $STATUS_RESPONSE"
          
          STATUS=$(echo "$STATUS_RESPONSE" | grep "status:" | awk '{print $2}')
          echo "Parsed status: $STATUS"
          
          if [ "$STATUS" = "Accepted" ]; then
            echo "Notarization successful!"
            break
          elif [ "$STATUS" = "Invalid" ] || [ "$STATUS" = "Rejected" ]; then
            echo "Notarization failed with status: $STATUS"
            xcrun notarytool log "$SUBMISSION_ID" --keychain-profile "notarytool-profile"
            exit 1
          fi
          
          ATTEMPTS=$((ATTEMPTS + 1))
          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "Timeout waiting for notarization after 15 minutes"
            exit 1
          fi
          
          echo "Waiting for notarization to complete... (Attempt $ATTEMPTS of $MAX_ATTEMPTS)"
          sleep 30
        done

        # Show notarization history for debugging
        xcrun notarytool history --keychain-profile "notarytool-profile"
        
    # Staple the Notarization Ticket to Distribution Package (Mac) - 2024.10.25 CLAUDE
    # ==========================================================================================
    - name: Staple Notarization Ticket
      if: matrix.os == 'macos-latest'
      env:
        REPOSITORY_NAME: ${{ github.event.repository.name }}
        APPLE_ID: ${{ secrets.APPLE_ID }}  # Used to check if notarization was run
      run: |
        # Check if notarization was meant to run
        if [ -z "$APPLE_ID" ]; then
          echo "Notarization credentials not set. Skipping stapling step."
          exit 0
        fi
    
        # Determine the suffix based on the version
        SUFFIX=""
        if [[ "${{ matrix.version }}" == "Demo" ]]; then
          SUFFIX=".D"
        fi
    
        # Store the installer path
        INSTALLER_PATH="${GITHUB_WORKSPACE}/build/${REPOSITORY_NAME}MacInstaller_${wPROJECT_VERSION}${SUFFIX}.pkg"
    
        echo "Stapling notarization ticket to installer..."
        xcrun stapler staple "$INSTALLER_PATH"
    
        echo "Validating stapled installer..."
        xcrun stapler validate "$INSTALLER_PATH"
    
        # Additional verification
        spctl --assess --type install "$INSTALLER_PATH"
    
        echo "Stapling process completed successfully."